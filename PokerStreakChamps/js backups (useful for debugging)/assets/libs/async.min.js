(function(t, e) {
"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define([ "exports" ], e) : e(t.async = {});
})(this, function(t) {
"use strict";
function e(t, ...e) {
return (...r) => t(...e, ...r);
}
function r(t) {
return function(...e) {
var r = e.pop();
return t.call(this, e, r);
};
}
function n(t) {
setTimeout(t, 0);
}
function i(t) {
return (e, ...r) => t(() => e(...r));
}
function u(t) {
return c(t) ? function(...e) {
const r = e.pop();
return o(t.apply(this, e), r);
} : r(function(e, r) {
var n;
try {
n = t.apply(this, e);
} catch (e) {
return r(e);
}
return n && "function" == typeof n.then ? o(n, r) : void r(null, n);
});
}
function o(t, e) {
return t.then(t => {
a(e, null, t);
}, t => {
a(e, t && t.message ? t : new Error(t));
});
}
function a(t, e, r) {
try {
t(e, r);
} catch (t) {
kt(t => {
throw t;
}, t);
}
}
function c(t) {
return "AsyncFunction" === t[Symbol.toStringTag];
}
function s(t) {
return "AsyncGenerator" === t[Symbol.toStringTag];
}
function l(t) {
return "function" == typeof t[Symbol.asyncIterator];
}
function f(t) {
if ("function" != typeof t) throw new Error("expected a function");
return c(t) ? u(t) : t;
}
function h(t, e = t.length) {
if (!e) throw new Error("arity is undefined");
return function(...r) {
return "function" == typeof r[e - 1] ? t.apply(this, r) : new Promise((n, i) => {
r[e - 1] = (t, ...e) => t ? i(t) : void n(1 < e.length ? e : e[0]), t.apply(this, r);
});
};
}
function p(t) {
return function(e, ...r) {
return h(function(n) {
var i = this;
return t(e, (t, e) => {
f(t).apply(i, r.concat(e));
}, n);
});
};
}
function v(t, e, r, n) {
e = e || [];
var i = [], u = 0, o = f(r);
return t(e, (t, e, r) => {
var n = u++;
o(t, (t, e) => {
i[n] = e, r(t);
});
}, t => {
n(t, i);
});
}
function y(t) {
return t && "number" == typeof t.length && 0 <= t.length && 0 == t.length % 1;
}
function m(t) {
function e(...e) {
if (null !== t) {
var r = t;
t = null, r.apply(this, e);
}
}
return Object.assign(e, t), e;
}
function d(t) {
return t[Symbol.iterator] && t[Symbol.iterator]();
}
function g(t) {
var e = -1, r = t.length;
return function() {
return ++e < r ? {
value: t[e],
key: e
} : null;
};
}
function S(t) {
var e = -1;
return function() {
var r = t.next();
return r.done ? null : (e++, {
value: r.value,
key: e
});
};
}
function b(t) {
var e = t ? Object.keys(t) : [], r = -1, n = e.length;
return function() {
var i = e[++r];
return r < n ? {
value: t[i],
key: i
} : null;
};
}
function w(t) {
if (y(t)) return g(t);
var e = d(t);
return e ? S(e) : b(t);
}
function k(t) {
return function(...e) {
if (null === t) throw new Error("Callback was already called.");
var r = t;
t = null, r.apply(this, e);
};
}
function E(t, e, r, n) {
function i() {
l >= e || s || a || (s = !0, t.next().then(({value: t, done: e}) => {
if (!c && !a) return s = !1, e ? (a = !0, void (0 >= l && n(null))) : void (l++, 
r(t, f, u), f++, i());
}).catch(o));
}
function u(t, e) {
return l -= 1, c ? void 0 : t ? o(t) : !1 === t ? (a = !0, void (c = !0)) : e === Et || a && 0 >= l ? (a = !0, 
n(null)) : void i();
}
function o(t) {
c || (s = !1, a = !0, n(t));
}
let a = !1, c = !1, s = !1, l = 0, f = 0;
i();
}
function L(t, e, r) {
function n(t, e) {
!1 === t && (a = !0);
!0 === a || (t ? r(t) : (++u === o || e === Et) && r(null));
}
r = m(r);
var i = 0, u = 0, {length: o} = t, a = !1;
for (0 === o && r(null); i < o; i++) e(t[i], i, k(n));
}
function A(t, e, r) {
return At(t, 1 / 0, e, r);
}
function x() {
function t(t, ...n) {
return t ? r(t) : void e(1 < n.length ? n : n[0]);
}
let e, r;
return t[Bt] = new Promise((t, n) => {
e = t, r = n;
}), t;
}
function j(t, e, r) {
function n(t, e) {
d.push(() => a(t, e));
}
function i() {
if (!p) {
if (0 === d.length && 0 === h) return r(null, l);
for (;d.length && h < e; ) d.shift()();
}
}
function u(t, e) {
var r = y[t];
r || (r = y[t] = []), r.push(e);
}
function o(t) {
(y[t] || []).forEach(t => t()), i();
}
function a(t, e) {
if (!v) {
var n = k((e, ...n) => {
if (h--, !1 !== e) if (2 > n.length && ([n] = n), e) {
var i = {};
if (Object.keys(l).forEach(t => {
i[t] = l[t];
}), i[t] = n, v = !0, y = Object.create(null), p) return;
r(e, i);
} else l[t] = n, o(t); else p = !0;
});
h++;
var i = f(e[e.length - 1]);
1 < e.length ? i(l, n) : i(n);
}
}
function c(e) {
var r = [];
return Object.keys(t).forEach(n => {
const i = t[n];
Array.isArray(i) && 0 <= i.indexOf(e) && r.push(n);
}), r;
}
"number" != typeof e && (r = e, e = null), r = m(r || x());
var s = Object.keys(t).length;
if (!s) return r(null);
e || (e = s);
var l = {}, h = 0, p = !1, v = !1, y = Object.create(null), d = [], g = [], S = {};
return Object.keys(t).forEach(e => {
var r = t[e];
if (!Array.isArray(r)) return n(e, [ r ]), void g.push(e);
var i = r.slice(0, r.length - 1), o = i.length;
return 0 === o ? (n(e, r), void g.push(e)) : void (S[e] = o, i.forEach(a => {
if (!t[a]) throw new Error("async.auto task `" + e + "` has a non-existent dependency `" + a + "` in " + i.join(", "));
u(a, () => {
0 == --o && n(e, r);
});
}));
}), function() {
for (var t = 0; g.length; ) t++, c(g.pop()).forEach(t => {
0 == --S[t] && g.push(t);
});
if (t !== s) throw new Error("async.auto cannot execute tasks due to a recursive dependency");
}(), i(), r[Bt];
}
function O(t) {
const e = t.toString().replace(Pt, "");
let r = e.match(Ft);
if (r || (r = e.match(Mt)), !r) throw new Error("could not parse args in autoInject\nSource:\n" + e);
let [, n] = r;
return n.replace(/\s/g, "").split(Ct).map(t => t.replace(zt, "").trim());
}
function _(t, e) {
var r = {};
return Object.keys(t).forEach(e => {
function n(t, e) {
var r = i.map(e => t[e]);
r.push(e), f(u)(...r);
}
var i, u = t[e], o = c(u), a = !o && 1 === u.length || o && 0 === u.length;
if (Array.isArray(u)) i = [ ...u ], u = i.pop(), r[e] = i.concat(0 < i.length ? n : u); else if (a) r[e] = u; else {
if (i = O(u), 0 === u.length && !o && 0 === i.length) throw new Error("autoInject task functions require explicit parameters.");
o || i.pop(), r[e] = i.concat(n);
}
}), j(r, e);
}
function I(t, e) {
t.length = 1, t.head = t.tail = e;
}
function T(t, e, r) {
function n(t, e) {
v[t].push(e);
}
function i(t, e) {
const r = (...n) => {
u(t, r), e(...n);
};
v[t].push(r);
}
function u(t, e) {
return t ? e ? void (v[t] = v[t].filter(t => t !== e)) : v[t] = [] : Object.keys(v).forEach(t => v[t] = []);
}
function o(t, ...e) {
v[t].forEach(t => t(...e));
}
function a(t, e, r, n) {
function i(t, ...e) {
return t ? r ? o(t) : u() : 1 >= e.length ? u(e[0]) : void u(e);
}
if (null != n && "function" != typeof n) throw new Error("task callback must be a function");
g.started = !0;
var u, o, a = {
data: t,
callback: r ? i : n || i
};
if (e ? g._tasks.unshift(a) : g._tasks.push(a), y || (y = !0, kt(() => {
y = !1, g.process();
})), r || !n) return new Promise((t, e) => {
u = t, o = e;
});
}
function c(t) {
return function(e, ...r) {
h -= 1;
for (var n = 0, i = t.length; n < i; n++) {
var u = t[n], a = p.indexOf(u);
0 === a ? p.shift() : 0 < a && p.splice(a, 1), u.callback(e, ...r), null != e && o("error", e, u.data);
}
h <= g.concurrency - g.buffer && o("unsaturated"), g.idle() && o("drain"), g.process();
};
}
function s(t) {
return !(0 !== t.length || !g.idle() || (kt(() => o("drain")), 0));
}
if (null == e) e = 1; else if (0 === e) throw new RangeError("Concurrency must not be zero");
var l = f(t), h = 0, p = [];
const v = {
error: [],
drain: [],
saturated: [],
unsaturated: [],
empty: []
};
var y = !1;
const m = t => e => e ? void (u(t), n(t, e)) : new Promise((e, r) => {
i(t, (t, n) => t ? r(t) : void e(n));
});
var d = !1, g = {
_tasks: new Dt(),
* [Symbol.iterator]() {
yield* g._tasks[Symbol.iterator]();
},
concurrency: e,
payload: r,
buffer: e / 4,
started: !1,
paused: !1,
push: (t, e) => Array.isArray(t) ? s(t) ? void 0 : t.map(t => a(t, !1, !1, e)) : a(t, !1, !1, e),
pushAsync: (t, e) => Array.isArray(t) ? s(t) ? void 0 : t.map(t => a(t, !1, !0, e)) : a(t, !1, !0, e),
kill() {
u(), g._tasks.empty();
},
unshift: (t, e) => Array.isArray(t) ? s(t) ? void 0 : t.map(t => a(t, !0, !1, e)) : a(t, !0, !1, e),
unshiftAsync: (t, e) => Array.isArray(t) ? s(t) ? void 0 : t.map(t => a(t, !0, !0, e)) : a(t, !0, !0, e),
remove(t) {
g._tasks.remove(t);
},
process() {
var t = Math.min;
if (!d) {
for (d = !0; !g.paused && h < g.concurrency && g._tasks.length; ) {
var e = [], r = [], n = g._tasks.length;
g.payload && (n = t(n, g.payload));
for (var i, u = 0; u < n; u++) i = g._tasks.shift(), e.push(i), p.push(i), r.push(i.data);
h += 1, 0 === g._tasks.length && o("empty"), h === g.concurrency && o("saturated");
var a = k(c(e));
l(r, a);
}
d = !1;
}
},
length: () => g._tasks.length,
running: () => h,
workersList: () => p,
idle: () => 0 === g._tasks.length + h,
pause() {
g.paused = !0;
},
resume() {
!1 === g.paused || (g.paused = !1, kt(g.process));
}
};
return Object.defineProperties(g, {
saturated: {
writable: !1,
value: m("saturated")
},
unsaturated: {
writable: !1,
value: m("unsaturated")
},
empty: {
writable: !1,
value: m("empty")
},
drain: {
writable: !1,
value: m("drain")
},
error: {
writable: !1,
value: m("error")
}
}), g;
}
function B(t, e) {
return T(t, 1, e);
}
function F(t, e, r) {
return T(t, e, r);
}
function M(...t) {
var e = t.map(f);
return function(...t) {
var r = this, n = t[t.length - 1];
return "function" == typeof n ? t.pop() : n = x(), Vt(e, t, (t, e, n) => {
e.apply(r, t.concat((t, ...e) => {
n(t, e);
}));
}, (t, e) => n(t, ...e)), n[Bt];
};
}
function C(...t) {
return M(...t.reverse());
}
function z(...t) {
return function(...e) {
return e.pop()(null, ...t);
};
}
function P(t, e) {
return (r, n, i, u) => {
var o, a = !1;
const c = f(i);
r(n, (r, n, i) => {
c(r, (n, u) => n || !1 === n ? i(n) : t(u) && !o ? (a = !0, o = e(!0, r), i(null, Et)) : void i());
}, t => t ? u(t) : void u(null, a ? o : e(!1)));
};
}
function D(t) {
return (e, ...r) => f(e)(...r, (e, ...r) => {
"object" == typeof console && (e ? console.error && console.error(e) : console[t] && r.forEach(e => console[t](e)));
});
}
function V(t, e, r) {
const n = f(e);
return Ht(t, (...t) => {
const e = t.pop();
n(...t, (t, r) => e(t, !r));
}, r);
}
function q(t) {
return (e, r, n) => t(e, n);
}
function R(t) {
return c(t) ? t : function(...e) {
var r = e.pop(), n = !0;
e.push((...t) => {
n ? kt(() => r(...t)) : r(...t);
}), t.apply(this, e), n = !1;
};
}
function U(t, e, r, n) {
var i = Array(e.length);
t(e, (t, e, n) => {
r(t, (t, r) => {
i[e] = !!r, n(t);
});
}, t => {
if (t) return n(t);
for (var r = [], u = 0; u < e.length; u++) i[u] && r.push(e[u]);
n(null, r);
});
}
function Q(t, e, r, n) {
var i = [];
t(e, (t, e, n) => {
r(t, (r, u) => r ? n(r) : void (u && i.push({
index: e,
value: t
}), n(r)));
}, t => t ? n(t) : void n(null, i.sort((t, e) => t.index - e.index).map(t => t.value)));
}
function N(t, e, r, n) {
return (y(e) ? U : Q)(t, e, f(r), n);
}
function G(t, e, r) {
return ue(t, 1 / 0, e, r);
}
function W(t, e, r) {
return ue(t, 1, e, r);
}
function $(t, e, r) {
return ae(t, 1 / 0, e, r);
}
function H(t, e, r) {
return ae(t, 1, e, r);
}
function J(t, e = (t => t)) {
var n = Object.create(null), i = Object.create(null), u = f(t), o = r((t, r) => {
var o = e(...t);
o in n ? kt(() => r(null, ...n[o])) : o in i ? i[o].push(r) : (i[o] = [ r ], u(...t, (t, ...e) => {
t || (n[o] = e);
var r = i[o];
delete i[o];
for (var u = 0, a = r.length; u < a; u++) r[u](t, ...e);
}));
});
return o.memo = n, o.unmemoized = t, o;
}
function K(t, e) {
return se(xt, t, e);
}
function X(t, e, r) {
return se(Lt(e), t, r);
}
function Y(t, e) {
var r = f(t);
return T((t, e) => {
r(t[0], e);
}, e, 1);
}
function Z(t) {
return 1 + (t << 1);
}
function tt(t) {
return (t + 1 >> 1) - 1;
}
function et(t, e) {
return t.priority === e.priority ? t.pushCount < e.pushCount : t.priority < e.priority;
}
function rt(t, e) {
var r = Y(t, e);
return r._tasks = new le(), r.push = function(t, e = 0, n = (() => {})) {
if ("function" != typeof n) throw new Error("task callback must be a function");
if (r.started = !0, Array.isArray(t) || (t = [ t ]), 0 === t.length && r.idle()) return kt(() => r.drain());
for (var i, u = 0, o = t.length; u < o; u++) i = {
data: t[u],
priority: e,
callback: n
}, r._tasks.push(i);
kt(r.process);
}, delete r.unshift, r;
}
function nt(t, e, r, n) {
var i = [ ...t ].reverse();
return Vt(i, e, r, n);
}
function it(t) {
var e = f(t);
return r(function(t, r) {
return t.push((t, ...e) => {
let n = {};
if (t && (n.error = t), 0 < e.length) {
var i = e;
1 >= e.length && ([i] = e), n.value = i;
}
r(null, n);
}), e.apply(this, t);
});
}
function ut(t) {
var e;
return Array.isArray(t) ? e = t.map(it) : (e = {}, Object.keys(t).forEach(r => {
e[r] = it.call(this, t[r]);
})), e;
}
function ot(t, e, r, n) {
const i = f(r);
return N(t, e, (t, e) => {
i(t, (t, r) => {
e(t, !r);
});
}, n);
}
function at(t) {
return function() {
return t;
};
}
function ct(t, e, r) {
var n = {
times: ye,
intervalFunc: at(me)
};
if (3 > arguments.length && "function" == typeof t ? (r = e || x(), e = t) : (st(n, t), 
r = r || x()), "function" != typeof e) throw new Error("Invalid arguments for async.retry");
var i = f(e), u = 1;
return function t() {
i((e, ...i) => {
!1 === e || (e && u++ < n.times && ("function" != typeof n.errorFilter || n.errorFilter(e)) ? setTimeout(t, n.intervalFunc(u - 1)) : r(e, ...i));
});
}(), r[Bt];
}
function st(t, e) {
if ("object" == typeof e) t.times = +e.times || ye, t.intervalFunc = "function" == typeof e.interval ? e.interval : at(+e.interval || me), 
t.errorFilter = e.errorFilter; else {
if ("number" != typeof e && "string" != typeof e) throw new Error("Invalid arguments for async.retry");
t.times = +e || ye;
}
}
function lt(t, e) {
e || (e = t, t = null);
let n = t && t.arity || e.length;
c(e) && (n += 1);
var i = f(e);
return r((e, r) => {
function u(t) {
i(...e, t);
}
return (e.length < n - 1 || null == r) && (e.push(r), r = x()), t ? ct(t, u, r) : ct(u, r), 
r[Bt];
});
}
function ft(t, e) {
return se(_t, t, e);
}
function ht(t, e, n) {
var i = f(t);
return r((r, u) => {
var o, a = !1;
r.push((...t) => {
a || (u(...t), clearTimeout(o));
}), o = setTimeout(function() {
var e = t.name || "anonymous", r = new Error('Callback function "' + e + '" timed out.');
r.code = "ETIMEDOUT", n && (r.info = n), a = !0, u(r);
}, e), i(...r);
});
}
function pt(t) {
for (var e = Array(t); t--; ) e[t] = t;
return e;
}
function vt(t, e, r, n) {
var i = f(r);
return qt(pt(t), e, i, n);
}
function yt(t, e, r) {
return vt(t, 1 / 0, e, r);
}
function mt(t, e, r) {
return vt(t, 1, e, r);
}
function dt(t, e, r, n) {
3 >= arguments.length && "function" == typeof e && (n = r, r = e, e = Array.isArray(t) ? [] : {}), 
n = m(n || x());
var i = f(r);
return xt(t, (t, r, n) => {
i(e, t, r, n);
}, t => n(t, e)), n[Bt];
}
function gt(t) {
return (...e) => (t.unmemoized || t)(...e);
}
function St(t, e, r) {
const n = f(t);
return ke(t => n((e, r) => t(e, !r)), e, r);
}
var bt = "function" == typeof setImmediate && setImmediate, wt = "object" == typeof process && "function" == typeof process.nextTick, kt = i(bt ? setImmediate : wt ? process.nextTick : n);
const Et = {};
var Lt = t => (e, r, n) => {
function i(t, e) {
if (!c) if (f -= 1, t) a = !0, n(t); else if (!1 === t) a = !0, c = !0; else {
if (e === Et || a && 0 >= f) return a = !0, n(null);
h || u();
}
}
function u() {
for (h = !0; f < t && !a; ) {
var e = o();
if (null === e) return a = !0, void (0 >= f && n(null));
f += 1, r(e.value, e.key, k(i));
}
h = !1;
}
if (n = m(n), 0 >= t) throw new RangeError("concurrency limit cannot be less than 1");
if (!e) return n(null);
if (s(e)) return E(e, t, r, n);
if (l(e)) return E(e[Symbol.asyncIterator](), t, r, n);
var o = w(e), a = !1, c = !1, f = 0, h = !1;
u();
}, At = h(function(t, e, r, n) {
return Lt(e)(t, f(r), n);
}, 4), xt = h(function(t, e, r) {
return (y(t) ? L : A)(t, f(e), r);
}, 3), jt = h(function(t, e, r) {
return v(xt, t, e, r);
}, 3), Ot = p(jt), _t = h(function(t, e, r) {
return At(t, 1, e, r);
}, 3), It = h(function(t, e, r) {
return v(_t, t, e, r);
}, 3), Tt = p(It);
const Bt = Symbol("promiseCallback");
var Ft = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/, Mt = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/, Ct = /,/, zt = /(=.+)?(\s*)$/, Pt = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
class Dt {
constructor() {
this.head = this.tail = null, this.length = 0;
}
removeLink(t) {
return t.prev ? t.prev.next = t.next : this.head = t.next, t.next ? t.next.prev = t.prev : this.tail = t.prev, 
t.prev = t.next = null, this.length -= 1, t;
}
empty() {
for (;this.head; ) this.shift();
return this;
}
insertAfter(t, e) {
e.prev = t, e.next = t.next, t.next ? t.next.prev = e : this.tail = e, t.next = e, 
this.length += 1;
}
insertBefore(t, e) {
e.prev = t.prev, e.next = t, t.prev ? t.prev.next = e : this.head = e, t.prev = e, 
this.length += 1;
}
unshift(t) {
this.head ? this.insertBefore(this.head, t) : I(this, t);
}
push(t) {
this.tail ? this.insertAfter(this.tail, t) : I(this, t);
}
shift() {
return this.head && this.removeLink(this.head);
}
pop() {
return this.tail && this.removeLink(this.tail);
}
toArray() {
return [ ...this ];
}
* [Symbol.iterator]() {
for (var t = this.head; t; ) yield t.data, t = t.next;
}
remove(t) {
for (var e = this.head; e; ) {
var {next: r} = e;
t(e) && this.removeLink(e), e = r;
}
return this;
}
}
var Vt = h(function(t, e, r, n) {
n = m(n);
var i = f(r);
return _t(t, (t, r, n) => {
i(e, t, (t, r) => {
e = r, n(t);
});
}, t => n(t, e));
}, 4), qt = h(function(t, e, r, n) {
return v(Lt(e), t, r, n);
}, 4), Rt = h(function(t, e, r, n) {
var i = f(r);
return qt(t, e, (t, e) => {
i(t, (t, ...r) => t ? e(t) : e(t, r));
}, (t, e) => {
for (var r = [], i = 0; i < e.length; i++) e[i] && (r = r.concat(...e[i]));
return n(t, r);
});
}, 4), Ut = h(function(t, e, r) {
return Rt(t, 1 / 0, e, r);
}, 3), Qt = h(function(t, e, r) {
return Rt(t, 1, e, r);
}, 3), Nt = h(function(t, e, r) {
return P(t => t, (t, e) => e)(xt, t, e, r);
}, 3), Gt = h(function(t, e, r, n) {
return P(t => t, (t, e) => e)(Lt(e), t, r, n);
}, 4), Wt = h(function(t, e, r) {
return P(t => t, (t, e) => e)(Lt(1), t, e, r);
}, 3), $t = D("dir"), Ht = h(function(t, e, r) {
function n(t, ...e) {
return t ? r(t) : void (!1 === t || (u = e, a(...e, i)));
}
function i(t, e) {
return t ? r(t) : !1 === t ? void 0 : e ? void o(n) : r(null, ...u);
}
r = k(r);
var u, o = f(t), a = f(e);
return i(null, !0);
}, 3), Jt = h(function(t, e, r) {
return xt(t, q(f(e)), r);
}, 3), Kt = h(function(t, e, r, n) {
return Lt(e)(t, q(f(r)), n);
}, 4), Xt = h(function(t, e, r) {
return Kt(t, 1, e, r);
}, 3), Yt = h(function(t, e, r) {
return P(t => !t, t => !t)(xt, t, e, r);
}, 3), Zt = h(function(t, e, r, n) {
return P(t => !t, t => !t)(Lt(e), t, r, n);
}, 4), te = h(function(t, e, r) {
return P(t => !t, t => !t)(_t, t, e, r);
}, 3), ee = h(function(t, e, r) {
return N(xt, t, e, r);
}, 3), re = h(function(t, e, r, n) {
return N(Lt(e), t, r, n);
}, 4), ne = h(function(t, e, r) {
return N(_t, t, e, r);
}, 3), ie = h(function(t, e) {
var r = k(e), n = f(R(t));
return function t(e) {
return e ? r(e) : void (!1 === e || n(t));
}();
}, 2), ue = h(function(t, e, r, n) {
var i = f(r);
return qt(t, e, (t, e) => {
i(t, (r, n) => r ? e(r) : e(r, {
key: n,
val: t
}));
}, (t, e) => {
for (var r = {}, {hasOwnProperty: i} = Object.prototype, u = 0; u < e.length; u++) if (e[u]) {
var {key: o} = e[u], {val: a} = e[u];
i.call(r, o) ? r[o].push(a) : r[o] = [ a ];
}
return n(t, r);
});
}, 4), oe = D("log"), ae = h(function(t, e, r, n) {
n = m(n);
var i = {}, u = f(r);
return Lt(e)(t, (t, e, r) => {
u(t, e, (t, n) => t ? r(t) : void (i[e] = n, r(t)));
}, t => n(t, i));
}, 4), ce = i(wt ? process.nextTick : bt ? setImmediate : n), se = h((t, e, r) => {
var n = y(e) ? [] : {};
t(e, (t, e, r) => {
f(t)((t, ...i) => {
2 > i.length && ([i] = i), n[e] = i, r(t);
});
}, t => r(t, n));
}, 3);
class le {
constructor() {
this.heap = [], this.pushCount = Number.MIN_SAFE_INTEGER;
}
get length() {
return this.heap.length;
}
empty() {
return this.heap = [], this;
}
percUp(t) {
for (let e; 0 < t && et(this.heap[t], this.heap[e = tt(t)]); ) {
let r = this.heap[t];
this.heap[t] = this.heap[e], this.heap[e] = r, t = e;
}
}
percDown(t) {
for (let e, r; (e = Z(t)) < this.heap.length && (e + 1 < this.heap.length && et(this.heap[e + 1], this.heap[e]) && ++e, 
!et(this.heap[t], this.heap[e])); ) r = this.heap[t], this.heap[t] = this.heap[e], 
this.heap[e] = r, t = e;
}
push(t) {
t.pushCount = ++this.pushCount, this.heap.push(t), this.percUp(this.heap.length - 1);
}
unshift(t) {
return this.heap.push(t);
}
shift() {
let [t] = this.heap;
return this.heap[0] = this.heap[this.heap.length - 1], this.heap.pop(), this.percDown(0), 
t;
}
toArray() {
return [ ...this ];
}
* [Symbol.iterator]() {
for (let t = 0; t < this.heap.length; t++) yield this.heap[t].data;
}
remove(t) {
let e = 0;
for (let r = 0; r < this.heap.length; r++) t(this.heap[r]) || (this.heap[e] = this.heap[r], 
e++);
this.heap.splice(e);
for (let t = tt(this.heap.length - 1); 0 <= t; t--) this.percDown(t);
return this;
}
}
var fe = h(function(t, e) {
if (e = m(e), !Array.isArray(t)) return e(new TypeError("First argument to race must be an array of functions"));
if (!t.length) return e();
for (var r = 0, n = t.length; r < n; r++) f(t[r])(e);
}, 2), he = h(function(t, e, r) {
return ot(xt, t, e, r);
}, 3), pe = h(function(t, e, r, n) {
return ot(Lt(e), t, r, n);
}, 4), ve = h(function(t, e, r) {
return ot(_t, t, e, r);
}, 3);
const ye = 5, me = 0;
var de = h(function(t, e, r) {
return P(Boolean, t => t)(xt, t, e, r);
}, 3), ge = h(function(t, e, r, n) {
return P(Boolean, t => t)(Lt(e), t, r, n);
}, 4), Se = h(function(t, e, r) {
return P(Boolean, t => t)(_t, t, e, r);
}, 3), be = h(function(t, e, r) {
function n(t, e) {
var r = t.criteria, n = e.criteria;
return r < n ? -1 : r > n ? 1 : 0;
}
var i = f(e);
return jt(t, (t, e) => {
i(t, (r, n) => r ? e(r) : void e(r, {
value: t,
criteria: n
}));
}, (t, e) => t ? r(t) : void r(null, e.sort(n).map(t => t.value)));
}, 3), we = h(function(t, e) {
var r, n = null;
return Xt(t, (t, e) => {
f(t)((t, ...i) => !1 === t ? e(t) : void (2 > i.length ? [r] = i : r = i, n = t, 
e(t ? null : {})));
}, () => e(n, r));
}), ke = h(function(t, e, r) {
function n(t, ...e) {
if (t) return r(t);
a = e;
!1 === t || o(i);
}
function i(t, e) {
return t ? r(t) : !1 === t ? void 0 : e ? void u(n) : r(null, ...a);
}
r = k(r);
var u = f(e), o = f(t), a = [];
return o(i);
}, 3), Ee = h(function(t, e) {
function r(e) {
f(t[i++])(...e, k(n));
}
function n(n, ...u) {
return !1 === n ? void 0 : n || i === t.length ? e(n, ...u) : void r(u);
}
if (e = m(e), !Array.isArray(t)) return e(new Error("First argument to waterfall must be an array of functions"));
if (!t.length) return e();
var i = 0;
r([]);
});
t.default = {
apply: e,
applyEach: Ot,
applyEachSeries: Tt,
asyncify: u,
auto: j,
autoInject: _,
cargo: B,
cargoQueue: F,
compose: C,
concat: Ut,
concatLimit: Rt,
concatSeries: Qt,
constant: z,
detect: Nt,
detectLimit: Gt,
detectSeries: Wt,
dir: $t,
doUntil: V,
doWhilst: Ht,
each: Jt,
eachLimit: Kt,
eachOf: xt,
eachOfLimit: At,
eachOfSeries: _t,
eachSeries: Xt,
ensureAsync: R,
every: Yt,
everyLimit: Zt,
everySeries: te,
filter: ee,
filterLimit: re,
filterSeries: ne,
forever: ie,
groupBy: G,
groupByLimit: ue,
groupBySeries: W,
log: oe,
map: jt,
mapLimit: qt,
mapSeries: It,
mapValues: $,
mapValuesLimit: ae,
mapValuesSeries: H,
memoize: J,
nextTick: ce,
parallel: K,
parallelLimit: X,
priorityQueue: rt,
queue: Y,
race: fe,
reduce: Vt,
reduceRight: nt,
reflect: it,
reflectAll: ut,
reject: he,
rejectLimit: pe,
rejectSeries: ve,
retry: ct,
retryable: lt,
seq: M,
series: ft,
setImmediate: kt,
some: de,
someLimit: ge,
someSeries: Se,
sortBy: be,
timeout: ht,
times: yt,
timesLimit: vt,
timesSeries: mt,
transform: dt,
tryEach: we,
unmemoize: gt,
until: St,
waterfall: Ee,
whilst: ke,
all: Yt,
allLimit: Zt,
allSeries: te,
any: de,
anyLimit: ge,
anySeries: Se,
find: Nt,
findLimit: Gt,
findSeries: Wt,
flatMap: Ut,
flatMapLimit: Rt,
flatMapSeries: Qt,
forEach: Jt,
forEachSeries: Xt,
forEachLimit: Kt,
forEachOf: xt,
forEachOfSeries: _t,
forEachOfLimit: At,
inject: Vt,
foldl: Vt,
foldr: nt,
select: ee,
selectLimit: re,
selectSeries: ne,
wrapSync: u,
during: ke,
doDuring: Ht
}, t.apply = e, t.applyEach = Ot, t.applyEachSeries = Tt, t.asyncify = u, t.auto = j, 
t.autoInject = _, t.cargo = B, t.cargoQueue = F, t.compose = C, t.concat = Ut, t.concatLimit = Rt, 
t.concatSeries = Qt, t.constant = z, t.detect = Nt, t.detectLimit = Gt, t.detectSeries = Wt, 
t.dir = $t, t.doUntil = V, t.doWhilst = Ht, t.each = Jt, t.eachLimit = Kt, t.eachOf = xt, 
t.eachOfLimit = At, t.eachOfSeries = _t, t.eachSeries = Xt, t.ensureAsync = R, t.every = Yt, 
t.everyLimit = Zt, t.everySeries = te, t.filter = ee, t.filterLimit = re, t.filterSeries = ne, 
t.forever = ie, t.groupBy = G, t.groupByLimit = ue, t.groupBySeries = W, t.log = oe, 
t.map = jt, t.mapLimit = qt, t.mapSeries = It, t.mapValues = $, t.mapValuesLimit = ae, 
t.mapValuesSeries = H, t.memoize = J, t.nextTick = ce, t.parallel = K, t.parallelLimit = X, 
t.priorityQueue = rt, t.queue = Y, t.race = fe, t.reduce = Vt, t.reduceRight = nt, 
t.reflect = it, t.reflectAll = ut, t.reject = he, t.rejectLimit = pe, t.rejectSeries = ve, 
t.retry = ct, t.retryable = lt, t.seq = M, t.series = ft, t.setImmediate = kt, t.some = de, 
t.someLimit = ge, t.someSeries = Se, t.sortBy = be, t.timeout = ht, t.times = yt, 
t.timesLimit = vt, t.timesSeries = mt, t.transform = dt, t.tryEach = we, t.unmemoize = gt, 
t.until = St, t.waterfall = Ee, t.whilst = ke, t.all = Yt, t.allLimit = Zt, t.allSeries = te, 
t.any = de, t.anyLimit = ge, t.anySeries = Se, t.find = Nt, t.findLimit = Gt, t.findSeries = Wt, 
t.flatMap = Ut, t.flatMapLimit = Rt, t.flatMapSeries = Qt, t.forEach = Jt, t.forEachSeries = Xt, 
t.forEachLimit = Kt, t.forEachOf = xt, t.forEachOfSeries = _t, t.forEachOfLimit = At, 
t.inject = Vt, t.foldl = Vt, t.foldr = nt, t.select = ee, t.selectLimit = re, t.selectSeries = ne, 
t.wrapSync = u, t.during = ke, t.doDuring = Ht, Object.defineProperty(t, "__esModule", {
value: !0
});
});